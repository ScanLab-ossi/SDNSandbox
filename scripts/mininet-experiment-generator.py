#!/usr/bin/python

# Mininet-Generator
# This file is based on a tool from the assesing-mininet project on github.com
# This file parses Network Topologies in a CSV format describing the links in the topology.
# A python file for creating Mininet Topologies will be created as Output.
# The network code will also run a network experiment sending traffic
# from hosts to other hosts in the network.
#
#################################################################################
import os
import argparse
from csv import DictReader
from collections import namedtuple

Link = namedtuple('Link', 'From, To, Latency_in_ms')

output_code = r'''#!/usr/bin/python

"""
Custom topology for Mininet, generated by GraphML-Topo-to-Mininet-Network-Generator.
"""
from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import RemoteController
from mininet.node import Node
from mininet.link import TCLink
from mininet.log import setLogLevel
from mininet.util import dumpNodeConnections
from subprocess import Popen, PIPE, STDOUT
from os.path import expanduser
from sys import exit
import time

class GeneratedTopo( Topo ):
    """Internet Topology Zoo Specimen."""

    def __init__( self, **opts ):
        """Create a topology."""

        # Initialize Topology
        Topo.__init__( self, **opts )

        # add switches, hosts and edges between switch and corresponding host...
{0}

        # add edges between switches
{1}

topos = {{ 'generated': ( lambda: GeneratedTopo() ) }}

# HERE THE CODE DEFINITION OF THE TOPOLOGY ENDS

# the following code produces an executable script working with a remote controller
# and providing ssh access to the the mininet hosts


def setupNetwork(controller_ip):
    "Create network and start it"
    topo = GeneratedTopo()
    network = Mininet(topo=topo, controller=lambda a: RemoteController( a, ip=controller_ip, port=6653 ), link=TCLink)
    # Start network
    network.start()
    # adds root for ssh + starts net
    connectToRootNS(network)

    # DEBUGGING INFO
    print
    print "Dumping network links"
    dumpNodeConnections(network.hosts)
    dumpNodeConnections(network.switches)
    dumpNodeConnections(network.controllers)
    print
    print "*** Hosts addresses:"
    print
    for host in network.hosts:
        print host.name, host.IP()
    print

    print "Waiting for the controller to finish network setup..."
    countdown(3)
    print "PingAll to make sure everything's OK"
    network.pingAllFull()
    return network

def connectToRootNS( network, ip='10.123.123.1', prefixLen=8, routes=['10.0.0.0/8'] ):
    "Connect hosts to root namespace via switch. Starts network."
    "network: Mininet() network object"
    "ip: IP address for root namespace node"
    "prefixLen: IP address prefix length (e.g. 8, 16, 24)"
    "routes: host networks to route to"
    switch = network.switches[0]
    # Create a node in root namespace and link to switch 0
    root = Node( 'root', inNamespace=False )
    intf = TCLink( root, switch ).intf1
    root.setIP( ip, prefixLen, intf )
    # Add routes from root ns to hosts
    for route in routes:
        root.cmd( 'route add -net ' + route + ' dev ' + str( intf ) )


def countdown(t):
    while t:
        mins, secs = divmod(t, 60)
        timeformat = '{{:02d}}:{{:02d}}'.format(mins, secs)
        print(timeformat)
        time.sleep(1)
        t -= 1
    print('Done!')


def setupITG( network ):
    print "Adding sshd + ITGRecv to all network hosts" 
    for host in network.hosts:
        host.cmd( '/usr/sbin/sshd -D &')
        host.cmd( '~/scripts/ITGRecv.sh &' )


def runExp():
    print "Running senders"
    process = Popen(expanduser("~/scripts/run_senders.sh"),
                               stdout=PIPE,
                               stderr=STDOUT)
    while True:
        output = process.stdout.readline()
        if output == '' and process.poll() is not None:
            break
        if output:
            print output.strip()
    rc = process.poll()
    if rc:
        print "Simulation ended with non zero returncode: " + str(code)


def cleanup(network):
    print "Killing ITGRecv(s)..."
    for host in network.hosts:
        host.cmd('pkill sshd')
        host.cmd( 'pkill ITGRecv.sh')
    print "Stopping the network..."
    network.stop()


if __name__ == '__main__':
    try:
        {2}
        {3}
        net = setupNetwork(controller_ip)
    except KeyboardInterrupt:
        print "Interrupted... Exiting..."
        exit(0)
    try:
        setupITG(net)
        runExp()
    except KeyboardInterrupt:
        cleanup(net)
        exit(0)
    cleanup(net)
'''


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--input",required=True, help="The input file - a CSV file of links in the topology")
    parser.add_argument("-o", "--output", default="", help="The output file - a mininet script based on the topology")
    parser.add_argument("-b", "--host-bandwidth", default="10", help="Host-Switch bandwidth in Mbps")
    parser.add_argument("-s", "--switch-bandwidth", default="100", help="Switch-Switch Bandwidth in Mbps")
    parser.add_argument("-c", "--controller-ip", required=True, help="The Controller's IP address")
    parser.add_argument("-d", "--debug", action="store_true", help="Set mininet verbosity to high (debug level)")

    args = parser.parse_args()

    if args.output == "":
        args.output = args.input + '-generated-Mininet-Topo.py'
    return args


def int2dpid(dpid):
    try:
        dpid = hex(dpid)[2:]
        dpid = '0' * ( 16 - len( dpid ) ) + dpid
        return dpid
    except IndexError:
        raise Exception('Unable to derive default datapath ID - '
                        'please either specify a dpid or use a '
                        'canonical switch name such as s23.' )


def add_switches_with_linked_host(switches, bandwidth):
    output = ''
    for s in range(0, len(switches)):
        name = switches.pop()
        # create switch
        output += "        {0} = self.addSwitch('{0}', dpid='{1}')\n".format(name, int2dpid(s))
        # create corresponding host
        output += "        {0}_host = self.addHost('{0}-H')\n".format(name)
        # link each switch and its host...
        output += "        self.addLink({0}, {0}_host, bw={1})\n".format(name, bandwidth)
    return output


def add_switch_links(edges, bandwidth):
    switch_links = ""
    for e in edges:
        switch_links += "        self.addLink({0}, {1}, bw={2}, delay='{3}ms')\n".format(
            e.From, e.To, bandwidth, e.Latency_in_ms)
    return switch_links


if __name__ == '__main__':
    args = parse_arguments()

    if args.debug:
        logging_output = "setLogLevel('debug')"
    else:
        logging_output = "setLogLevel('info')"

    links = []
    with open(args.input) as topo_csv:
        csv_reader = DictReader(topo_csv)
        for link in csv_reader:
            links.append(Link(**link))

    switches = set([link.From for link in links] + [link.To for link in links])

    add_switches_with_linked_host_output = add_switches_with_linked_host(switches, args.host_bandwidth)

    add_switch_links_output = add_switch_links(links, args.switch_bandwidth)

    controller_ip_output = "controller_ip = '{0}'".format(args.controller_ip)

    with open(args.output, 'w') as f:
        f.write(output_code.format(add_switches_with_linked_host_output,
                                   add_switch_links_output,
                                   logging_output,
                                   controller_ip_output))
    # give the output executable permissions
    st = os.stat(args.output)
    os.chmod(args.output, st.st_mode | 0o0111)

    print("Topology mininet script generation SUCCESSFUL!")
